4.3 новый взгляд на строки

append(аргумент)		Добавляет аргумент, преобразованный в строку, в конец StringBuilder-а.
delete(int start, int end)	удаляет подпоследовательность с start до end - 1 включительно
delete(int index)		удаляет символ по индексу.
insert(int offset, аргумент)	Вставляет аргумент, конвертированный в строку, в позицию offset, это работает медленно.
setCharAt(int index, char c)	Заменяет указанный символ.
reverse()			Меняет порядок символов в StringBuilder на обратный. Первый символ становится последним и так далее. Работает быстро.
toString()			Возвращает строку, содержащую последовательность символов из StringBuilder. Эта самая важная функция. После изменения строки, ее обычно «собирают» в строку.

спец.символы в решулярных выражениях: ([{\^-=$!|]})?*+.
Метасимволы для поиска совпадений границ строк или текста:
	^	начало строки
	$	конец строки
	\\b	границы слова
	\\d	цифровой символ

	\\D	нецифровой символ
	\\s	пробельный символ: табуляция, перевод строки, пробел
	\\S	непробельный символ
	\\w	буквенно-цифровой символ или знак подчёркивания, эквивалентен [a-zA-Z0-9_]
	\\W	любой символ, кроме буквенного, цифрового или знака подчёркивания
	. (точка)	любой символ

	[abc]	любой из перечисленных (a,b, или c)
	[^abc]	любой, кроме перечисленных (не a, не b и не с)
	[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )
	[a-d[m-p]]	объединение символов (от a до d и от m до p)
	[a-z&&[def]]	пересечение символов (символы d,e,f)
	[a-z&&[^bc]]	вычитание символов (символы a, d-z)
	ab|cd	аb или cd, часто такое надо заключать в скобки

Метасимволы для обозначения количества символов — квантификаторы:
	?	один или отсутствует
	*	ноль или более раз
	+	один или более раз
	{n}	n раз
	{n,}	n раз и более
	{n,m}	не менее n раз и не более m раз
Например, \d{4} будет искать строку из четырех цифр. А \d+ — строку из любого количества цифр

Pattern - регулярка
Matcher - искалка

сервис для проверки регулярок: 
	https://www.freeformatter.com/java-regex-tester.html#before-output
	https://regex101.com/ , классно объясняет: https://www.youtube.com/watch?v=_pLpx6btq6U

Пример регулярки: \bc[a-z]*?t\b
\b - задаём поиск по границам слова
с - первый символ слова
[a-z] - поиск по символам вержнего и нижнего регистра


Метод / Количество вызовов	50 000 раз	200 000 раз	1 000 000 раз

append(аргумент)		9		20		30		
delete(int index)		3		7		9	
insert(0, аргумент)		191		3418		долго					
insert(length()/2, аргумент)	112		1771		45894
(вставка в середину)			
setCharAt(int index, char c)	6		5		8		
reverse()		





